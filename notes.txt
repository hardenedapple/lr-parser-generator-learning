One "parsing state" consists of all viable rules and position pairs.
- E.g. Beginning of 'Start', which is also beginning of 'Add', which is also
  beginning of 'Factor', ...

FOLLOW and FIRST help us decide what to do based on "the next item"
- FOLLOW is parametrised by the *itemset*
  (So FOLLOW(itemset1, symbol) rather than FOLLOW(symbol)).
- According to https://boxbase.org/entries/2019/oct/14/lr1-parsing-tables/,
  FIRST is not the transitive closure -- it is just direct.
  Though this may be mitigated by the fact that in that tutorial any itemset
  contains all rules effective at this point.  Hence this could be an effective
  transitive closure.

LR(1) parser 


Manual itemsets:


Without shifts or reduces mentioned.

s0:  Start  -> . Add
    Add    -> . Add "+" Factor
    Add    -> . Factor
    Factor -> . Factor "*" Term
    Factor -> . Term
    Term   -> . "(" Add ")"
    Term   -> . name
    Term   -> . int
    
s1:  Start -> Add .
    Add   -> Add . "+" Factor

s2:  Add   -> Factor .
    Factor -> Factor . "*" Term

s3:  Factor -> Term .

s4:  Term   -> "(" . Add ")"
    Add    -> . Add "+" Factor
    Add    -> . Factor
    Factor -> . Factor "*" Term
    Factor -> . Term
    Term   -> . "(" Add ")"
    Term   -> . name
    Term   -> . int
    
s5:  Term -> name .

s6:  Term -> int .

s7:  Add -> Add "+" . Factor
    Factor -> . Factor "*" Term
    Factor -> . Term
    Term   -> . "(" Add ")"
    Term   -> . name
    Term   -> . int

s8:  Factor -> Factor "*" . Term
    Term   -> . "(" Add ")"
    Term   -> . name
    Term   -> . int

s9:  Term  -> "(" Add . ")"
    Add   -> Add . "+" Factor

s10: Factor -> Factor "*" Term .

s11: Add -> Add "+" Factor .
     Factor -> Factor . "*" Term

s12: Term  -> "(" Add ")" .


With shifts and reduces (but without lookahead)

Reduction Items:
s1: Start -> Add .
s2: Add   -> Factor .
s3: Factor -> Term .
s5: Term -> name .
s6: Term -> int .
s10: Factor -> Factor "*" Term .
s11: Add -> Add "+" Factor .
s12: Term -> "(" Add ")" .

Tables with shift/reduce annotations
s0:  Start  -> . Add                
    Add    -> . Add "+" Factor      
    Add    -> . Factor              
    Factor -> . Factor "*" Term     
    Factor -> . Term                
    Term   -> . "(" Add ")"         
    Term   -> . name                
    Term   -> . int                 

Actions:
    Add:    Shift 1 / Reduce 1 Start
    Factor: Shift 2 / Reduce 1 Start
    Term:   Shift 3 / Reduce 1 Start
    "(":    Shift 4
    name:   Shift 5 / Reduce 1 Start
    int:    Shift 6 / Reduce 1 Start
    
s1:  Start -> Add .
    Add   -> Add . "+" Factor

Actions:
          Reduce 1 Start
    "+":  Shift 7

s2:  Add   -> Factor .
    Factor -> Factor . "*" Term

Actions:
          Reduce 1 Add
    "*":  Shift 8

s3:  Factor -> Term .

Actions:
          Reduce 1 Factor

s4:  Term   -> "(" . Add ")"
    Add    -> . Add "+" Factor
    Add    -> . Factor
    Factor -> . Factor "*" Term
    Factor -> . Term
    Term   -> . "(" Add ")"
    Term   -> . name
    Term   -> . int

Actions:
    Add:     Shift 9
    Factor:  Shift 2 / Reduce 1 Add
    Term:    Shift 3 / Reduce 1 Factor
    "(":     Shift 4
    name:    Shift 5 / Reduce 1 Term
    int:     Shift 6 / Reduce 1 Term
    
s5:  Term -> name .

Actions:
             Reduce 1 Term

s6:  Term -> int .

Actions:
             Reduce 1 Term

s7:  Add -> Add "+" . Factor
    Factor -> . Factor "*" Term
    Factor -> . Term
    Term   -> . "(" Add ")"
    Term   -> . name
    Term   -> . int

Actions:
    Factor:  Shift 11 / Reduce 3 Add
    Term :   Shift 3 / Reduce 1 Factor
    "(":     Shift 4
    name:    Shift 5 / Reduce 1 Term
    int:     Shift 6 / Reduce 1 Term

s8:  Factor -> Factor "*" . Term
    Term   -> . "(" Add ")"
    Term   -> . name
    Term   -> . int

Actions:
    Term: Shift 10 / Reduce 3 Factor
    "(":     Shift 4
    name:    Shift 5 / Reduce 1 Term
    int:     Shift 6 / Reduce 1 Term

s9:  Term  -> "(" Add . ")"
    Add   -> Add . "+" Factor

Actions:
    ")":  Shift 12 / Reduce 3 Term
    "+":  Shift 7

s10: Factor -> Factor "*" Term .

Actions:
          Reduce 3 Factor

s11: Add -> Add "+" Factor .
     Factor -> Factor . "*" Term

Actions:
          Reduce 3 Add
     "*": Shift 8

s12: Term  -> "(" Add ")" .

Actions:
          Reduce 3 Term


Attempting to remove the conflicts:

FIRST According to this tutorial is different to that according to the other one.
This one has empty sets for symbols that are not started with a non-terminal.  The other tutorial used a transitive closure so that such non-terminals would have the same FIRST set as their non-terminal initial value.
FIRST(symbol)
	FIRST(Start) = {}
	FIRST(Add) = {}
	FIRST(Factor) = {}
	FIRST(Term) = {"(", name, int}

If we were it make the transitive closure, we would see:
FIRST(symbol)
	FIRST(Start) = {"(", int, name}
	FIRST(Add) = {"(", int, name}
	FIRST(Factor) = {"(", int, name}
	FIRST(Term) = {"(", name, int}

FOLLOW:  Difference between this tutorial and the other one is that FOLLOW is parametrised on itemset.

I *think* FOLLOW has looked through FIRST sets here, and has looked through them transitively (which seems odd given that the FIRST sets were not defined transitively).

FOLLOW(0, Add) = {01, "+", ")"}
FOLLOW(0, Factor) = {03, "*", "+", ")"}
FOLLOW(0, Term) = {05, "*", "+", ")"}
FOLLOW(0, "(") = {"(", int, name}
FOLLOW(0, name) = {07, "*", "+", ")"}
FOLLOW(0, int) = {08, "*", "+", ")"}

FOLLOW(1, "+") = {"(", int, name}

FOLLOW(2, "*") = {"(", int, name}

FOLLOW(4, Add) = {")", "+"}
FOLLOW(4, Factor) = {"*", ")", "+"}
FOLLOW(4, Term) = {"*", ")", "+"}
FOLLOW(4, "(") = {"(", int, name}
FOLLOW(4, int) = {"*", ")", "+"}
FOLLOW(4, name) = {"*", ")", "+"}

FOLLOW(7, Factor) = {01, "*"}
FOLLOW(7, Term)   = {03, "*"}
FOLLOW(7, "(")    = {"(", int, name}
FOLLOW(7, name)   = {05, "*"}
FOLLOW(7, int)   = {06, "*"}

FOLLOW(8, Term)  = {01}
FOLLOW(8, "(")   = {"(", int, name}
FOLLOW(8, name)  = {03}
FOLLOW(8, int)   = {04}

FOLLOW(9, ")")   = {01}
FOLLOW(9, "+")   = {"(", name, int}

FOLLOW(11, "*")  = {"(", int, name}

Global Follow sets (for SLR):
FOLLOW(Add) = {$, "+", ")",}
FOLLOW(Factor) = {$, "*", "+", ")"}
FOLLOW(Term) = {$, "*", "+", ")"}
FOLLOW("(") = {"(", int, name}
FOLLOW(name) = {$, "*", "+", ")"}
FOLLOW(int) = {$, "*", "+", ")"}
FOLLOW(")") = {$, "*", "+", ")"}


------------------------------
Resolving decision table conflict:
Declare that after 'Start', input stream should end.
Lookahead tables after each set describe what is expected after the rule.

N.b. predict that the Add rule follows itself?
- What is this assumption for?
- Should I apply it?

Going with adding TC(FIRST(Add)) to the "lookahead" of Add rule in the very first thing.
However, this does not make sense in the context of the grammar that we're using.  There can not be another Add directly after the first one (because "x + y z + l" is not valid).

Looking back at the first tutorial that I found confusing -- the "Parsing State" that it talks about includes a lookahead set.
That lookahead set comes from the previous rule that we've expanded for.
So in the below, since 'Factor -> . Term' was added as part of 'Add -> . Factor', and 'Factor -> . Factor "*" Term', we need the lookahead set to include '$' from the 'Add' rule, and "*" from the 'Factor' rule.

Question:
  Does the following thought hold?
  - 'Factor -> . Factor "*" Term' could be expanded *from itself*, hence it could be followed by a "*".
  Though is that it probably does ... similar for 'Factor -> . Term' being generated from the rule above.

s0:  Start  -> . Add             {$}
    Add    -> . Add "+" Factor   {$}
    Add    -> . Factor           {$, "+"}
    Factor -> . Factor "*" Term  {$, "+", "*"}
    Factor -> . Term             {$, "+", "*"}
    Term   -> . "(" Add ")"      {$, "+", "*"}
    Term   -> . name             {$, "+", "*"}
    Term   -> . int              {$, "+", "*"}

s1: Start -> Add .               {$}
    Add   -> Add . "+" Factor    {$}

-- What is expected after this rule?
   Entirely depends on how we got to this state right?
   This is not a property of the itemset ...
s2: Add   -> Factor .            {$, 

.....

Since this "lookahead" thing above is confusing, let's attempt to fix conflicts with what we have.


-- In state zero, I wonder if there are any Reduce choices anyway?
   Looking back I don't think there are ...
s0:  Start  -> . Add                
    Add    -> . Add "+" Factor      
    Add    -> . Factor              
    Factor -> . Factor "*" Term     
    Factor -> . Term                
    Term   -> . "(" Add ")"         
    Term   -> . name                
    Term   -> . int                 

Actions:
    Add:    Shift 1
    Factor: Shift 2
    Term:   Shift 3
    "(":    Shift 4
    name:   Shift 5
    int:    Shift 6

s1:  Start -> Add .
    Add   -> Add . "+" Factor

Actions:
    "$":  Reduce 1 Start
    "+":  Shift 7
    default:  Error (do not allow anything after Start)

-- Here, if going from the itemset only, we have "$" and "*".
   I know this is incorrect, because there is often something else after an Add.
   The "something else" could be thought of as the "global" FOLLOW set (unless we start encoding where this state could come from).

According to the below link, SLR has a global FOLLOW set, while LR carries into each state a relevant FOLLOW set (hence ending up with more states).
https://www.cs.wustl.edu/~cytron/cse431/Current/Tutorial/part4.pdf
Looking at the FOLLOW sets "falling into" this set (still ignoring which *rule* this comes from -- FOLLOW(0, Add) == {01, "+", ")"}, but the ")" comes from Term and doesn't lead to this state).
There is even clearer statement of this in the below document:
https://web.stanford.edu/class/archive/cs/cs143/cs143.1128/handouts/110%20LR%20and%20SLR%20Parsing.pdf
From s0: 

s2:  Add   -> Factor .           {$, "+", ")"}
    Factor -> Factor . "*" Term  {"*"}

Actions:
    "$":  Reduce 1 Add
    "+":  Reduce 1 Add
    ")":  Reduce 1 Add
    "*":  Shift 8
    default:  Error

s3:  Factor -> Term .   

Actions:
          Reduce 1 Factor

s4:  Term   -> "(" . Add ")"
    Add    -> . Add "+" Factor
    Add    -> . Factor
    Factor -> . Factor "*" Term
    Factor -> . Term
    Term   -> . "(" Add ")"
    Term   -> . name
    Term   -> . int

Actions:
    Add:     Shift 9
    Factor:  Shift 2
    Term:    Shift 3
    "(":     Shift 4
    name:    Shift 5
    int:     Shift 6


-----------------------------------------------
Going with the SLR approach first (now that I know these are two different approaches):
doing this mostly because I believe those are the states that I created earlier.


s0:  Start  -> . Add                
    Add    -> . Add "+" Factor      
    Add    -> . Factor              
    Factor -> . Factor "*" Term     
    Factor -> . Term                
    Term   -> . "(" Add ")"         
    Term   -> . name                
    Term   -> . int                 

Actions:
    Add:    Shift 1
    Factor: Shift 2
    Term:   Shift 3
    "(":    Shift 4
    name:   Shift 5
    int:    Shift 6
    
s1:  Start -> Add .
    Add   -> Add . "+" Factor

Actions:
    "$":  Reduce 1 Start
    "+":  Shift 7
    any:  Error

s2:  Add   -> Factor .
    Factor -> Factor . "*" Term

Actions:
    "$":  Reduce 1 Add
    "+":  Reduce 1 Add
    ")":  Reduce 1 Add
    "*":  Shift 8
    any:  Error

s3:  Factor -> Term .

Actions:
    "$":  Reduce 1 Factor
    "*":  Reduce 1 Factor
    "+":  Reduce 1 Factor
    ")":  Reduce 1 Factor
    any:  Error

s4:  Term   -> "(" . Add ")"
    Add    -> . Add "+" Factor
    Add    -> . Factor
    Factor -> . Factor "*" Term
    Factor -> . Term
    Term   -> . "(" Add ")"
    Term   -> . name
    Term   -> . int

Actions:
    Add:     Shift 9
    Factor:  Shift 2
    Term:    Shift 3
    "(":     Shift 4
    name:    Shift 5
    int:     Shift 6
    
s5:  Term -> name .

Actions:
     "$":    Reduce 1 Term
     "+":    Reduce 1 Term
     "*":    Reduce 1 Term
     ")":    Reduce 1 Term
     any:    Error

s6:  Term -> int .

Actions:
     "$":    Reduce 1 Term
     "+":    Reduce 1 Term
     "*":    Reduce 1 Term
     ")":    Reduce 1 Term
     any:    Error

s7:  Add -> Add "+" . Factor
    Factor -> . Factor "*" Term
    Factor -> . Term
    Term   -> . "(" Add ")"
    Term   -> . name
    Term   -> . int

Actions:
    Factor:  Shift 11
    Term :   Shift 3
    "(":     Shift 4
    name:    Shift 5
    int:     Shift 6

s8:  Factor -> Factor "*" . Term
    Term   -> . "(" Add ")"
    Term   -> . name
    Term   -> . int

Actions:
    Term: Shift 10
    "(":     Shift 4
    name:    Shift 5
    int:     Shift 6

s9:  Term  -> "(" Add . ")"
    Add   -> Add . "+" Factor

Actions:
    ")":  Shift 12
    "+":  Shift 7

s10: Factor -> Factor "*" Term .

Actions:
    "$":  Reduce 3 Factor
    "*":  Reduce 3 Factor
    "+":  Reduce 3 Factor
    ")":  Reduce 3 Factor
    any:  Error

s11: Add -> Add "+" Factor .
     Factor -> Factor . "*" Term

Actions:
     "$"  Reduce 3 Add
     "+"  Reduce 3 Add
     ")"  Reduce 3 Add
     "*": Shift 8
     any: Error

s12: Term  -> "(" Add ")" .

Actions:
     "$":    Reduce 3 Term
     "+":    Reduce 3 Term
     "*":    Reduce 3 Term
     ")":    Reduce 3 Term
     any:    Error


